<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 这里其实和前面一样，数组里看似是三个一样的函数的函数体，但是这三个函数其实保留了各自作用域的数据
        // 所以在调用不同函数体的时候，打印出来的数据是不一样的
        let arr = [];
        for (let i = 1; i <= 3; i++) {
            arr.push(function() {
                return i
            })
        }
        console.log(arr[0]())
        console.log(arr[1]())
        console.log(arr[2]())

        // 因为var不产生各自的作用域块，所以每个函数的中的数据不会被保留下来
        // 推到数组里的就是单纯的不附带各自数据的函数体，到最后打印出来的也就是最后的全局数据 
        let arrVar = []
        for (var j = 1; j <= 3; j++) {
            // var a = 0
            // a = j
            arrVar.push(function() {
                return j
            })
        }
        // console.log('a', a)
        console.log(arrVar[0]())
        console.log(arrVar[1]())
        console.log(arrVar[2]())


        // 在这里需要讨论的就是为什么var本身不产生独立的作用域块，但是每次循环的数据却被保留了下来
        // 数据会被保留，原因是构成了闭包，一个函数里面套了一层函数，中间夹的那个数据就会被保留
        // 这个例子中，push里面的那个函数在被调用的时候会往上找数据
        // 上个例子里直接找到for循环的数据，而这个数据是会随着循环的推进不断被覆盖的
        // 但是这个例子里的数据其实是那个立即执行函数的内部数据，不会被销毁
        // 所以是可以一直调用的
        let arrVarFun = []
        for (var k = 1; k <= 3; k++) {
            (function(k) {
                // var b = 0
                // b = k
                console.log('k保留了吗', k)
                arrVarFun.push(function() {
                    return k
                })
            })(k)
        }
        // console.log('b', b)
        console.log(arrVarFun[0]())
        console.log(arrVarFun[1]())
        console.log(arrVarFun[2]())
        console.log(arrVarFun)

        // 以上八节小课，如果要形成闭包都满足三点
        // 是外层函数形成的作用域块套内层函数 或者是let作用域块里面的函数
        // 会变化的数据都放在外层与内层之间，而且会随着同一个作用域块的内层函数一起操作
        // 内层函数都需要被一个全局变量保存下来，而且是保存其函数体，再用函数体重新调用
    </script>
</body>

</html>